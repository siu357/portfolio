<!DOCTYPE html>
<html lang="en" class="html" data-theme="light"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>
    
      Fly And Shoot
    
  </title>

  <!-- Begin Jekyll SEO tag v2.7.3 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Fly And Shoot" />
<meta name="author" content="이윤찬" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="소개" />
<meta property="og:description" content="소개" />
<link rel="canonical" href="http://localhost:4000/fly-and-shoot" />
<meta property="og:url" content="http://localhost:4000/fly-and-shoot" />
<meta property="og:site_name" content="이윤찬의 포트폴리오" />
<meta property="og:image" content="https://soopr.xyz/images/card?url=http://localhost:4000/fly-and-shoot" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-01-01T00:00:00+09:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="og:image" content="https://soopr.xyz/images/card?url=http://localhost:4000/fly-and-shoot" />
<meta property="twitter:title" content="Fly And Shoot" />
<script type="application/ld+json">
{"url":"http://localhost:4000/fly-and-shoot","headline":"Fly And Shoot","dateModified":"2024-01-01T00:00:00+09:00","datePublished":"2024-01-01T00:00:00+09:00","@type":"BlogPosting","author":{"@type":"Person","name":"이윤찬"},"description":"소개","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/fly-and-shoot"},"@context":"https://schema.org"}</script>
<script async defer data-soopr-token="" src="https://sdk.soopr.co/soopr.js"  ></script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="이윤찬의 포트폴리오" />

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/assets/images/favicon/site.webmanifest">
  <link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/assets/images/favicon/favicon.ico">
  <meta name="msapplication-TileColor" content="#00aba9">
  <meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  <!-- Favicon -->

  <link rel="stylesheet" href="/assets/css/main.css" />
  
    <script type="text/javascript">
  window.addEventListener('load', themeChange);
  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme)
    document.documentElement.setAttribute('data-theme', currentTheme);

  function themeChange() {
    let button = document.querySelector('.theme-toggle');

    button.addEventListener('click', function (e) {
      let currentTheme = document.documentElement.getAttribute('data-theme');
      if (currentTheme === 'dark') {
        transition();
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
      } else {
        transition();
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
      }
    });

    let transition = () => {
      document.documentElement.classList.add('transition');
      window.setTimeout(() => {
        document.documentElement.classList.remove('transition');
      }, 1000);
    }
  }
</script>


  
</head>
<body>
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">돌아가기</a>
<h1 class="post-title">Fly And Shoot</h1>
<p class="post-date text-bold">
  
    <span class="text-upcase">이윤찬</span> / 
  
  
    <span class="text-upcase">January 2024</span>
  


  
  
  (1113 Words, 
  7 Minutes)
  

</p>

<div class="soopr-btn"
   data-twitter="SooprCo"
>
</div>


  <div class="">
    
    <span class="tag">DirectX9</span>
    
    <span class="tag">C++</span>
    
    <span class="tag">Game Project</span>
    
  </div>


<h1 id="소개">소개</h1>

<p><strong>제작 언어 및 엔진</strong> : C++, DirectX9</p>

<p><strong>제작 기간</strong> : 약 2주</p>

<p>다이렉트X9으로 제작한 간단한 비행/슈팅 데모입니다.</p>

<h1 id="플레이-영상">플레이 영상</h1>

<iframe width="560" height="315" src="https://www.youtube.com/embed/bIe2OedLrOE?si=LJWHAzUVSbFePoYt" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<ul>
  <li>주요 타임 스탬프
    <ul>
      <li>00:05 : 개체의 회전</li>
      <li>00:24 : 전후좌우 이동</li>
      <li>00:43 : 상하 이동</li>
      <li>00:51 : 크기 조정</li>
      <li>01:08 : 뷰 모드 전환</li>
    </ul>
  </li>
</ul>

<h1 id="주요-기능">주요 기능</h1>

<ul>
  <li>조작
    <ul>
      <li>전/후진 및 좌/우측 이동</li>
      <li>방향전환</li>
      <li>Scaling</li>
      <li>상승/하강</li>
      <li>뷰 모드 전환</li>
    </ul>
  </li>
  <li>GUI</li>
  <li>빌보드</li>
  <li>버텍스 버퍼</li>
  <li>인덱스 버퍼</li>
</ul>

<h1 id="주요-기술-및-코드">주요 기술 및 코드</h1>

<h2 id="1-이동-및-회전">1. 이동 및 회전</h2>

<p>다이렉트X는 <strong>렌더링 파이프라인</strong>이라 부르는 일련의 연산 과정을 통해 결과물이 출력되는데, 이 중 <strong>버텍스 쉐이더</strong> 단계에서 물체의 이동 및 회전 등의 좌표 처리를 실시합니다.</p>

<p>버텍스 쉐이더의 과정을 요약하면</p>
<ul>
  <li>로컬 좌표계에 존재하는 오브젝트를 3D 월드 좌표에 배치 (World Transform)
  <br /> World Transform의 3가지 세부과정
    <ul>
      <li>Scale (크기 변화)</li>
      <li>Rotation (회전)</li>
      <li>Translation (이동)</li>
    </ul>
  </li>
  <li>월드 좌표계를 카메라의 위치, 바라보는 방향에 맞추어 변환 (View Transform)</li>
  <li>결과물을 2D 스크린상으로 투영 (Projection Transform)</li>
</ul>

<p>각각은 행렬(Matrix)로 표현되며, 이 행렬을 연산하는 것으로 과정이 진행됩니다.</p>

<p>이하는 비행체 본체의 행렬연산 과정입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VOID Translate()
{
    if (GetAsyncKeyState(KeyW))
    {
        D3DXVec3TransformCoord(&amp;vecTemp, &amp;vecFront, &amp;matRot);
        vecWorldDir += vecTemp * 0.1 * __MOVEMENT__;
    }
    if (GetAsyncKeyState(KeyA))
    {
        D3DXVec3TransformCoord(&amp;vecTemp, &amp;vecSide, &amp;matRot);
        vecWorldDir -= vecTemp * 0.1 * __MOVEMENT__;
    }
    if (GetAsyncKeyState(KeyS))
    {
        D3DXVec3TransformCoord(&amp;vecTemp, &amp;vecFront, &amp;matRot);
        vecWorldDir -= vecTemp * 0.1 * __MOVEMENT__;
    }
    if (GetAsyncKeyState(KeyD))
    {
        D3DXVec3TransformCoord(&amp;vecTemp, &amp;vecSide, &amp;matRot);
        vecWorldDir += vecTemp * 0.1 * __MOVEMENT__;
    }
    if (GetAsyncKeyState(VK_SPACE))
    {
        D3DXVec3TransformCoord(&amp;vecTemp, &amp;vecVertical, &amp;matRot);
        vecWorldDir += vecTemp * 0.1 * __MOVEMENT__;
    }
    if (GetAsyncKeyState(VK_CONTROL))
    {
        D3DXVec3TransformCoord(&amp;vecTemp, &amp;vecVertical, &amp;matRot);
        vecWorldDir -= vecTemp * 0.1 * __MOVEMENT__;
    }
}

VOID Render()
{
    // 전략
    D3DXMatrixScaling(&amp;matScale, vecScale.x, vecScale.y, vecScale.z);
    D3DXMatrixRotationYawPitchRoll(&amp;matRot, vecDegree.y * D3DX_PI / 180, vecDegree.x * D3DX_PI / 180, vecDegree.z * D3DX_PI / 180);
    D3DXMatrixTranslation(&amp;matTranslation, vecWorldDir.x + vecBasePos.x, vecWorldDir.y + vecBasePos.y, vecWorldDir.z + vecBasePos.z);
    
    matWorld = matScale * matRot * matTranslation; // Scale * Rot * Translate 순으로.
    g_pd3dDevice-&gt;SetTransform(D3DTS_WORLD, &amp;matWorld);
    // 후략
}
</code></pre></div></div>
<p>현재 객체의 회전값을 가진 행렬인 <code class="language-plaintext highlighter-rouge">matRot</code>에 단위 방향벡터를 곱합니다.
 이동속도의 조절을 위해 상수 <code class="language-plaintext highlighter-rouge">0.1 * __MOVEMENT__</code>를 곱해준 후 결과값을 객체의 위치값 <code class="language-plaintext highlighter-rouge">vecWorldDir</code>에 누적합니다.</p>

<p>최종적으로 개체의 위치값에 해당하는 <code class="language-plaintext highlighter-rouge">matTranslation</code>은 <code class="language-plaintext highlighter-rouge">vecWorldDir</code>에 초기 위치값인 <code class="language-plaintext highlighter-rouge">vecBasePos</code>를 더하여 설정합니다.</p>

<p>화면에 출력하는 <code class="language-plaintext highlighter-rouge">Render()</code>과정에서 Scale-&gt;Rotation-&gt;Translation 순으로 연산하여 이를 World Transform으로 설정합니다.
<br /></p>
<h2 id="2-총알의-발사">2. 총알의 발사</h2>
<p>총알은 별도의 클래스 <code class="language-plaintext highlighter-rouge">CBullet</code>에서 필요한 요소와 관련한 행렬 및 벡터, 함수를 다룹니다.
 부모에 해당하는 비행체 본체의 발사 순간의 위치와 회전값을 받아 초기화하며,
 유니티의 오브젝트 풀링 개념을 채용해 총알의 거리가 일정량 이상이 되면 다시 초기화해 재활용하는 방식으로 오버헤드를 줄였습니다.</p>

<p>총알 발사 로직의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VOID CBullet::BulletTranslate(D3DXVECTOR3 vecFront)
{
	D3DXVECTOR3 vecTempBullet;
	D3DXVec3TransformCoord(&amp;vecTempBullet, &amp;vecFront, GetMatRotBulletAddress());
	SetVecWorldDir(GetVecWorldDir() + vecTempBullet * 0.1f * __MOVEMENT_BULLET__);
	
	SetDistance(GetDistance() + 0.1f);
}

VOID CBullet::BulletReset(D3DXMATRIX matParent, D3DXMATRIX matRot)
{
	// Object Pooling
	if (GetDistance() &gt; __BULLET_DISTANCE__)
	{
	//D3DXVECTOR3 vecWorldDir = GetVecWorldDirParent;

	// 위치 초기화
	SetVecWorldDir(D3DXVECTOR3(0, 0, 0));

	// 부모의 회전 matrix와 같게 (같은 회전된 형태로 발사됨)
	SetMatRotBullet(matRot);

	// 본체의 위치에서 발사가 시작되도록 부모의 위치 설정
	D3DXVECTOR3 vecTempDir;
	D3DXVec3TransformCoord(&amp;vecTempDir, &amp;vecBasePos, &amp;matParent);
	D3DXMatrixTranslation(GetMatTranslateParentAddress(), vecTempDir.x, vecTempDir.y, vecTempDir.z);

	SetDistance(.0f);
	}
}

VOID Render()
{
    // 전략
    g_pd3dDevice-&gt;SetTexture(0, g_ppTexture_Bullet);
    g_pd3dDevice-&gt;SetStreamSource(0, g_pVB_Bullet, 0, sizeof(CUSTOMVERTEX));

    D3DXVECTOR3 tempVecDegreeBullet = bullet-&gt;GetVecDegree();
    D3DXVECTOR3 tempVecBullet = bullet-&gt;GetVecPos();
    D3DXVECTOR3 tempVecWorldDirBullet = bullet-&gt;GetVecWorldDir();

    D3DXMatrixScaling(&amp;matScale, vecScale.x / 5, vecScale.y / 5, vecScale.z / 5);
    D3DXMatrixRotationYawPitchRoll(bullet-&gt;GetMatRevRotBulletAddress(), tempVecDegreeBullet.y * D3DX_PI / 180, tempVecDegreeBullet.x * D3DX_PI / 180, tempVecDegreeBullet.z * D3DX_PI / 180);
    D3DXMatrixTranslation(bullet-&gt;GetMatTranslateBulletAddress(), tempVecWorldDirBullet.x + tempVecBullet.x, tempVecWorldDirBullet.y + tempVecBullet.y, tempVecWorldDirBullet.z + tempVecBullet.z);

    bullet-&gt;SetMatWorldBullet(matScale * bullet-&gt;GetMatRotBullet() * bullet-&gt;GetMatTranslateParent() * bullet-&gt;GetMatRevRotBullet() * bullet-&gt;GetMatTranslateBullet());
    g_pd3dDevice-&gt;SetTransform(D3DTS_WORLD, bullet-&gt;GetMatWorldBulletAddress());
    g_pd3dDevice-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 24, 0, 6 * 2);
    // 후략
}
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">BulletTranslate()</code>에서 총알의 위치를 담는 벡터 <code class="language-plaintext highlighter-rouge">vecWorldDir</code>의 위치값을 변화시키면서 이동한 거리를 누적시킵니다.</p>

<p>이동한 거리가 정의한 수치인 <code class="language-plaintext highlighter-rouge">__BULLET_DISTANCE__</code>에 도달하면 <code class="language-plaintext highlighter-rouge">BulletReset()</code>을 통해 총알의 위치와 회전값, 이동한 거리를 다시 초기화합니다.</p>

<p>버텍스 쉐이더 단계에서 총알이 가진 위치, 회전 행렬을 토대로 배치하고 출력합니다.</p>

<p>총알의 형태가 정육면체이기 때문에 총알 자체도 발사되는 방향에 맞게 회전되어야 하므로 추가적으로 <code class="language-plaintext highlighter-rouge">matRevRotBullet</code>을 선언하여 회전시켜줍니다.</p>

<p>최종 행렬 연산 순서는 총알의 크기 -&gt; 발사되는 위치의 회전(부모의 회전값) -&gt; 부모의 위치 -&gt; 총알 자체의 회전 -&gt; 총알의 위치가 됩니다.
<br /></p>
<h2 id="3-카메라-뷰-모드-전환">3. 카메라 뷰 모드 전환</h2>
<p>많은 3D 게임들이 카메라의 바라보는 방향, 즉 View를 바꾸는 기능을 갖고 있습니다.</p>

<p>해당 데모에서도 해당 기능을 구현했으며 개체의 뒤에서 바라보는 Back View, 위에서 바라보는 Top View, 대각선 위치에서 바라보는 Top Back View를 사전에 정의했습니다.</p>

<p>이하는 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VOID SwitchView()
{
    if (GetAsyncKeyState('V'))
    {
        switch (nViewMode)
        {
        case __BACK__:
            nViewMode = __TOP__;
            break;
        case __TOP__:
            nViewMode = __TOPBACK__;
            break;
        case __TOPBACK__:
            nViewMode = __BACK__;
            break;
        }
    }
}

VOID SetView()
{
    switch (nViewMode)
    {
    case __BACK__:
        vecEye = D3DXVECTOR3(0, vecWorldDir.y + vecBasePos.y, vecWorldDir.z + vecBasePos.z - 3);
        vecLookAt = D3DXVECTOR3(0, vecWorldDir.y + vecBasePos.y, vecWorldDir.z + vecBasePos.z);
        vecUp = D3DXVECTOR3(0, 1, 0);
        break;
    case __TOP__:
        vecEye = D3DXVECTOR3(0, vecWorldDir.y + vecBasePos.y + 3, vecWorldDir.z + vecBasePos.z - 0.01);
        vecLookAt = D3DXVECTOR3(0, vecWorldDir.y + vecBasePos.y, vecWorldDir.z + vecBasePos.z);
        vecUp = D3DXVECTOR3(0, 1, 0);
        break;
    case __TOPBACK__:
        vecEye = D3DXVECTOR3(0, vecWorldDir.y + vecBasePos.y + 3, vecWorldDir.z + vecBasePos.z - 3);
        vecLookAt = D3DXVECTOR3(0, vecWorldDir.y + vecBasePos.y, vecWorldDir.z + vecBasePos.z);
        vecUp = D3DXVECTOR3(0, 1, 0);
        break;
    }
}

VOID Render()
{
    // 전략
    D3DXMATRIX tempViewTM;
    SetView();
    D3DXMatrixLookAtLH(&amp;tempViewTM, &amp;vecEye, &amp;vecLookAt, &amp;vecUp);
    g_pd3dDevice-&gt;SetTransform(D3DTS_VIEW, &amp;tempViewTM);
    // 후략
}
</code></pre></div></div>
<p>View Transform은 Eye, LookAt, Up이라는 세 개의 벡터로 구성됩니다. Finite State Machine의 형태로 제어한 <code class="language-plaintext highlighter-rouge">nViewMode</code>를 <code class="language-plaintext highlighter-rouge">SwitchView()</code>에서 순차적으로 전환하고,
 <code class="language-plaintext highlighter-rouge">SetView()</code>에서 현재 <code class="language-plaintext highlighter-rouge">nViewMode</code>에 맞추어 Eye, LookAt, Up 벡터를 설정합니다.
<br /></p>
<h2 id="4-빌보드-및-gui">4. 빌보드 및 GUI</h2>
<p>3D게임에서 주변 환경을 표현하는데 사용되는 것들로 나무, 구름 등이 있습니다.</p>

<p>자연스럽고 사실적인 표현을 위해서는 많은 수가 배치되어야 하는데, 이들을 일일이 3D 폴리곤으로 출력하는 것은 오버헤드가 매우 큽니다.</p>

<p>따라서 원거리에 있는 오브젝트들의 경우 2D 사각형의 형태로 간략화 후 카메라를 바라보도록 회전시켜 연산량을 줄이는데, 이러한 처리가 된 오브젝트들을 빌보드라고 부릅니다.</p>

<p>빌보드와 GUI의 구현 과정입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define D3DFVF_CUSTOMVERTEX_UI (D3DFVF_XYZRHW | D3DFVF_TEX1)

VOID Render()
{
    // 전략
    // Billboard
    D3DXMatrixIdentity(&amp;matRotBillboard);
    matRotBillboard._11 = tempViewTM._11;
    matRotBillboard._13 = tempViewTM._13;
    matRotBillboard._31 = tempViewTM._31;
    matRotBillboard._33 = tempViewTM._33;
    D3DXMatrixInverse(&amp;matRotBillboard, NULL, &amp;matRotBillboard);

    for (int i = 0; i &lt; vVecBillboard.size(); i++)
    {
        D3DXMatrixTranslation(&amp;matTranslationBillboard, vVecBillboard[i].x, vVecBillboard[i].y, vVecBillboard[i].z);
        matWorldBillboard = matRotBillboard * matTranslationBillboard;
        g_pd3dDevice-&gt;SetTransform(D3DTS_WORLD, &amp;matWorldBillboard);

        g_pd3dDevice-&gt;SetTexture(0, g_ppTexture_Billboard);
        g_pd3dDevice-&gt;SetStreamSource(0, g_pVB_Billboard, 0, sizeof(CUSTOMVERTEX));
        g_pd3dDevice-&gt;SetFVF(D3DFVF_CUSTOMVERTEX);
        g_pd3dDevice-&gt;SetIndices(g_pIB_Billboard);
        g_pd3dDevice-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 4, 0, 1 * 2);
    }
    
    // UI
    g_pd3dDevice-&gt;SetTexture(0, g_ppTextureUI);
    g_pd3dDevice-&gt;SetFVF(D3DFVF_CUSTOMVERTEX_UI);
    g_pd3dDevice-&gt;DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, verticesUI, sizeof(CUSTOMVERTEX2));
    // 후략
}
</code></pre></div></div>
<p>빌보드에 해당하는 물체들은 항상 카메라를 응시하도록 회전시켜야 하므로 뷰 트랜스폼 <code class="language-plaintext highlighter-rouge">tempViewTM</code>의 y축에 대한 역행렬 정보를 회전행렬로 정의합니다.</p>

<p>GUI는 항상 똑같은 위치에 2D의 형태로 출력되어야 하므로 버텍스 버퍼를 <code class="language-plaintext highlighter-rouge">D3DFVF_XYZRHW</code>로 정의해 행렬변환 과정을 생략합니다.
<br /></p>
<h2 id="5-버텍스인덱스-버퍼">5. 버텍스/인덱스 버퍼</h2>

<p>다이렉트X에서는 3D 물체를 출력하기 위해 물체의 정점(Vertices) 정보가 필요합니다. 이 정점을 미리 저장해 두는 것(Buffer)을 버텍스 버퍼라고 부릅니다.</p>

<p>한 편, 삼각형의 집합으로 표현되는 폴리곤에서는 출력에 필요한 정점 정보가 필연적으로 중복됩니다. 이를 최소화 하여 메모리 사용량을 줄이는 것이 인덱스 버퍼로, 버텍스의 집합을 선언 후 몇 번째 버텍스들을 사용할 것인지 저장해 둡니다.</p>

<p>이하는 버텍스 및 인덱스 버퍼 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HRESULT InitVB(LPDIRECT3DDEVICE9&amp; g_pd3dDevice, LPDIRECT3DVERTEXBUFFER9&amp; g_pVB, LPDIRECT3DTEXTURE9&amp; g_ppTexture, VOID* pVertices, int n)
{
    int a, b;
    // Cube
    g_pd3dDevice-&gt;CreateVertexBuffer(
        sizeof(vertices),
        0,
        D3DFVF_XYZ,
        D3DPOOL_DEFAULT,
        &amp;g_pVB,
        NULL);
    D3DXCreateTextureFromFile(g_pd3dDevice, "Skill_Dark_Sight.bmp", &amp;g_ppTexture);
    a = sizeof(vertices);
    b = sizeof(CUSTOMVERTEX);

    g_pVB-&gt;Lock(0, sizeof(vertices), (void**)&amp;pVertices, 0);
    memcpy(pVertices, vertices, sizeof(vertices));
    g_pVB-&gt;Unlock();
    return S_OK;
}

VOID InitIB(LPDIRECT3DDEVICE9&amp; g_pd3dDevice, LPDIRECT3DINDEXBUFFER9&amp; g_pIB)
{
	int iNumberOfIndex = sizeof(indices) / sizeof(WORD);

	g_pd3dDevice-&gt;CreateIndexBuffer(
		sizeof(WORD) * iNumberOfIndex,
		0,
		D3DFMT_INDEX16,
		D3DPOOL_DEFAULT,
		&amp;g_pIB,
		NULL);

	VOID* pIndices;

	g_pIB-&gt;Lock(0, sizeof(WORD) * iNumberOfIndex, (void**)&amp;pIndices, 0);
	memcpy(pIndices, indices, sizeof(indices));
	g_pIB-&gt;Unlock();
}

HRESULT InitD3D(HWND hWnd)
{
    // 전략
    // Vertex Buffer 초기화
    InitVB(g_pd3dDevice, g_pVB, g_ppTexture, pVertices, 0);
    InitVB_Bullet(g_pd3dDevice, g_pVB_Bullet, g_ppTexture_Bullet, pVertices, 0);
    InitVB_Billboard(g_pd3dDevice, g_pVB_Billboard, g_ppTexture_Billboard, pVertices_Billboard, 0);

    // Index Buffer 초기화
    D3DXCreateTextureFromFile(g_pd3dDevice, "HP_bar.bmp", &amp;g_ppTextureUI);
    InitIB(g_pd3dDevice, g_pIB);
    InitIB_Billboard(g_pd3dDevice, g_pIB_Billboard);
    // 후략
}
</code></pre></div></div>
<p>출력할 개체마다 따로 초기화를 진행하며, 전체 초기화 시에 버텍스/인덱스 버퍼 초기화를 실시합니다.
<br /></p>

<hr data-content="footnotes" />


        
          <button title="Toggle Theme" class="theme-toggle">
  <svg viewBox="0 0 32 32" width="24" height="24" fill="currentcolor">
    <circle cx="16" cy="16" r="14" fill="none" stroke="currentcolor" stroke-width="4"></circle>
    <path d="
             M 16 0
             A 16 16 0 0 0 16 32
             z">
    </path>
  </svg>
</button>

        
        <div class="credits">&copy;&nbsp;2024&nbsp;이윤찬
          &nbsp;
          •
          &nbsp;Powered by <a href="https://www.soopr.co" target="_blank" rel="noreferrer">Soopr</a>
          &nbsp;
          •
          &nbsp;Theme&nbsp; <a href="https://github.com/abhinavs/moonwalk" target="_blank" rel="noreferrer">Moonwalk</a>
        </div>
      </div>
    </main><script async defer src="https://sdk.soopr.co/soopr.js"></script></body>
</html>
