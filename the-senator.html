<!DOCTYPE html>
<html lang="en" class="html" data-theme="light"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>
    
      The Senator
    
  </title>

  <!-- Begin Jekyll SEO tag v2.7.3 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="The Senator" />
<meta name="author" content="이윤찬" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="소개" />
<meta property="og:description" content="소개" />
<link rel="canonical" href="http://localhost:4000/the-senator" />
<meta property="og:url" content="http://localhost:4000/the-senator" />
<meta property="og:site_name" content="이윤찬의 포트폴리오" />
<meta property="og:image" content="https://soopr.xyz/images/card?url=http://localhost:4000/the-senator" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-04-01T00:00:00+09:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="og:image" content="https://soopr.xyz/images/card?url=http://localhost:4000/the-senator" />
<meta property="twitter:title" content="The Senator" />
<script type="application/ld+json">
{"url":"http://localhost:4000/the-senator","headline":"The Senator","dateModified":"2023-04-01T00:00:00+09:00","datePublished":"2023-04-01T00:00:00+09:00","@type":"BlogPosting","author":{"@type":"Person","name":"이윤찬"},"description":"소개","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/the-senator"},"@context":"https://schema.org"}</script>
<script async defer data-soopr-token="" src="https://sdk.soopr.co/soopr.js"  ></script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="이윤찬의 포트폴리오" />

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/assets/images/favicon/site.webmanifest">
  <link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/assets/images/favicon/favicon.ico">
  <meta name="msapplication-TileColor" content="#00aba9">
  <meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  <!-- Favicon -->

  <link rel="stylesheet" href="/assets/css/main.css" />
  
    <script type="text/javascript">
  window.addEventListener('load', themeChange);
  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme)
    document.documentElement.setAttribute('data-theme', currentTheme);

  function themeChange() {
    let button = document.querySelector('.theme-toggle');

    button.addEventListener('click', function (e) {
      let currentTheme = document.documentElement.getAttribute('data-theme');
      if (currentTheme === 'dark') {
        transition();
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
      } else {
        transition();
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
      }
    });

    let transition = () => {
      document.documentElement.classList.add('transition');
      window.setTimeout(() => {
        document.documentElement.classList.remove('transition');
      }, 1000);
    }
  }
</script>


  
</head>
<body>
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">돌아가기</a>
<h1 class="post-title">The Senator</h1>
<p class="post-date text-bold">
  
    <span class="text-upcase">이윤찬</span> / 
  
  
    <span class="text-upcase">April 2023</span>
  


  
  
  (1624 Words, 
  10 Minutes)
  

</p>

<div class="soopr-btn"
   data-twitter="SooprCo"
>
</div>


  <div class="">
    
    <span class="tag">Unity Engine</span>
    
    <span class="tag">C#</span>
    
    <span class="tag">Game Project</span>
    
  </div>


<h1 id="소개">소개</h1>

<p><strong>제작 언어 및 엔진</strong> : C#, Unity Engine HDRP<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p><strong>제작 기간</strong> : 약 2개월</p>

<p>코지마 프로덕션의 메탈기어 라이징 리벤전스를 모티브로 하여 만든 1vs1 액션 게임으로, <strong>플레이어의 컨트롤 요소를 극대화</strong>하고, 각종 효과로 <strong>시각적 만족도</strong>를 높이는데 중점을 두었습니다.</p>

<h1 id="플레이-영상">플레이 영상</h1>

<iframe width="560" height="315" src="https://www.youtube.com/embed/wEmL8iSdcy0?si=dCgajaNZnW4heORk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<ul>
  <li>주요 타임 스탬프
    <ul>
      <li>00:05 : 대화 컷씬</li>
      <li>00:22 : 기본 조작</li>
      <li>00:48 : 특수 패턴 1</li>
      <li>01:03 : 패링</li>
      <li>01:15 : 옵션 - 스탯 분배</li>
      <li>01:27 : 옵션 - 난이도</li>
      <li>01:49 : 옵션 - 그래픽</li>
      <li>02:10 : 2페이즈 진입</li>
      <li>02:24 : 특수 패턴 1 강화</li>
      <li>02:32 : 특수 패턴 2</li>
      <li>02:43 : 특수 패턴 2 방어</li>
      <li>02:48 : QTE 성공</li>
      <li>03:18 : QTE 실패</li>
      <li>04:18 : 마지막 QTE</li>
    </ul>
  </li>
</ul>

<h1 id="주요-기능">주요 기능</h1>

<ul>
  <li>메인화면, 대화 컷씬, 전투로 나뉜 구성</li>
  <li>QTE<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></li>
  <li>컨트롤 요소
    <ul>
      <li>방어 및 패링 : 적절한 타이밍에 방어하면 적을 잠시 경직시키며, 스킬 사용에 필요한 MP를 회복</li>
      <li>점프 및 구르기 : 적의 특정 공격을 회피, 늦은 타이밍에 사용해 피격 시 넘어지는 등의 패널티 요소</li>
      <li>무기 : 검, 활 등을 원하는 대로 선택해 자신만의 스타일로 전투</li>
      <li>스킬 : MP를 소모하고 딜레이가 큰 대신, 큰 데미지를 줄 수 있음, 쿨타임 기능</li>
    </ul>
  </li>
  <li>연출
    <ul>
      <li>패링 성공 및 QTE 도중 시간이 느려지고, 화면에 뿌옇게 되는 등의 효과</li>
      <li>타격 성공 및 피격 시 해당 위치에 이펙트 발생 및 카메라 흔들림</li>
    </ul>
  </li>
  <li>난이도 및 페이즈 시스템
    <ul>
      <li>체력, 데미지 뿐만 아니라 패턴 강화, QTE난이도 강화 등의 다양한 요소를 구현</li>
    </ul>
  </li>
  <li>스탯 분배 시스템
    <ul>
      <li>초기 및 중간에 지급되는 골드로 원하는 스탯에 분배해 자신만의 빌드로 전투</li>
    </ul>
  </li>
  <li>편의성 및 그래픽 설정
    <ul>
      <li>락 온 시스템으로 편한 조준 가능</li>
      <li>게임 시작 시 안내 문구로 간단한 조작법 설명</li>
      <li>Ambient Occulsion, Vignette, Depth of Field 등의 그래픽 효과 조작</li>
    </ul>
  </li>
  <li>GUI 및 애니메이션
    <ul>
      <li>플레이어의 초상화, HP/MP 체력바, 각종 스탯 수치, 스킬 쿨타임 표시</li>
      <li>체력의 변동이나 쿨타임 등을 천천히 변화하도록 애니메이션화</li>
    </ul>
  </li>
  <li>최적화
    <ul>
      <li>여러 번 사용되는 개체는 오브젝트 풀링으로 오버헤드 최소화</li>
      <li>불필요한 충돌 처리 최소화</li>
    </ul>
  </li>
</ul>

<h1 id="주요-기술-및-코드">주요 기술 및 코드</h1>

<h2 id="1-qte">1. QTE</h2>

<p><img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211258&amp;authkey=%21ACquolHj7F2mqsI&amp;width=1920&amp;height=1080" alt="QTE1" />
<img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211259&amp;authkey=%21AJuikicZ6exUY7Y&amp;width=1920&amp;height=1080" alt="QTE2" /></p>

<p>게임을 클리어하기 위해서는 QTE를 연달아 성공해야 합니다.</p>

<p>QTE에서 등장할 아이콘, 시간 안에 누르기 위해 점점 좁아지는 원 및 관련 기능을 하나의 클래스에 구현했습니다.</p>

<p>원이 아이콘의 크기와 같아지기 전에 지시된 키를 누르면 QTE 성공, 잘못된 키를 누르거나 시간 안에 누르지 못하면 실패처리됩니다.</p>

<p>우선 Dictionary로 등장할 키를 매핑해 두고, 난이도에 따라 누르기 까다로운 위치의 키(왼손 주변에 위치한 키가 누르기 편할 것입니다.)는 제외하는 등의 처리를 해줍니다.</p>

<p>이하는 일정한 속도로 좁아지는 원을 Coroutine으로 구현한 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IEnumerator QTECircle(float speed)
{
    qteLimit.GetComponent&lt;RectTransform&gt;().localScale = new Vector3(3, 3, 1);
    int rnd;
    if (PlayerAxis.Instance.difficulty != PlayerAxis.Difficulty.senator)
    {
        rnd = GetRandomNumberExcluded(); // 누르기 까다로운 위치의 키는 제외 (Easy ~ Hard)
        key = (char)rnd;
    }
    else // Senator 난이도는 모든 키가 QTE 이벤트에서 등장
    {
        rnd = Random.Range(65, 91); // A~Z (Senator)
        key = (char)rnd;
    }
    if(GameObject.Find("Senator Armstrong").GetComponent&lt;Enemy_Behave&gt;().qteFirstStage == 3) // 마지막 QTE는 누르기 까다로운 위치로
    {
        rnd = GetRandomNumberExcludedInverse();
        key = (char)rnd;
    }
    qteText.text = key.ToString();
    while(qteLimit.GetComponent&lt;RectTransform&gt;().localScale.x &gt; 1)
    {
        yield return null;
        qteLimit.GetComponent&lt;RectTransform&gt;().localScale -= new Vector3(speed, speed, 0);
        if (Input.anyKeyDown)
        {
            foreach (var dic in keyDictionary)
            {
                if(Input.GetKeyDown(dic.Key) &amp;&amp; dic.Value == key)
                {
                    QTESuccess();
                }
                else if (Input.GetKeyDown(dic.Key) &amp;&amp; dic.Value != key)
                {
                    QTEFail();
                }
            }
        }
    }
    if(qteLimit.GetComponent&lt;RectTransform&gt;().localScale.x &lt;= 1) // 시간 초과
    {
        QTEFail();
    }
}
</code></pre></div></div>
<p>반복문 <code class="language-plaintext highlighter-rouge">while(qteLimit.GetComponent&lt;RectTransform&gt;().localScale.x &gt; 1)</code> 에서 정의해 놓은 속도로 원의 크기가 줄어듭니다.</p>

<p>시간 내에 올바르게 수행하면 <code class="language-plaintext highlighter-rouge">QTESuccess()</code>로 성공 시의 동작을 행하고, 잘못 누르거나 시간초과가 되면 <code class="language-plaintext highlighter-rouge">QTEFail()</code>이 실행됩니다.
<br /></p>
<h2 id="2-최적화--오브젝트-풀링">2. 최적화 : 오브젝트 풀링</h2>
<p>개체가 많을 경우 생성 및 파괴 시의 오버헤드는 무시하기 힘듭니다.</p>

<p>한 런타임 내에서 같은 종류의 오브젝트가 여러 번 사용될 경우, <strong>사용된 오브젝트를 비활성화 후 보관한 뒤 다시 필요한 순간에 활성화 및 초기화하여 사용합니다.</strong> 이를 오브젝트 풀링이라 부릅니다.</p>

<p>결과적으로 한 런타임에서 한 종류의 오브젝트는 동시에 존재했던 최대치까지만 생성되어 유지됩니다.</p>

<p>본 프로젝트에는 생성과 파괴가 잦은 모든 오브젝트에 대해 해당 기법을 적용했습니다.</p>

<p>이하는 오브젝트 풀링을 적용한 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 패링 시 이펙트 효과
void ParryImpact()
{
    // Object Pooling
    float rnd_x = Random.Range(-0.2f, 0.2f);
    float rnd_y = Random.Range(-0.2f, 0.2f);
    for (int i = 0; i &lt; parryEffectPool.Count; i++)
    {
        if (!parryEffectPool[i].activeSelf)
        {
            parryEffectPool[i].SetActive(true);
            parryEffectPool[i].transform.position = parryEffectRegion.transform.position + new Vector3(rnd_x, rnd_y, 0);
            return;
        }
    }
    GameObject obj = Instantiate(parryEffect, parryEffectRegion.transform.position + new Vector3(rnd_x, rnd_y, 0), Quaternion.identity);
    obj.transform.parent = parryEffectParent.transform;
    parryEffectPool.Add(obj);
}
</code></pre></div></div>
<p>반복문 <code class="language-plaintext highlighter-rouge">for (int i = 0; i &lt; parryEffectPool.Count; i++)</code> 에서 풀링된 오브젝트들 중 비활성화된(현재 사용중이지 않은) 개체를 활성화시킨 후 위치를 초기화 합니다.</p>

<p>사용가능한 오브젝트가 없으면 새로 생성 후 위치를 초기화 하고, 부모인 ‘풀’에 해당 오브젝트를 자식으로 지정하여 종속시킵니다.
<br /></p>
<h2 id="3-최적화--충돌-처리-비활성화">3. 최적화 : 충돌 처리 비활성화</h2>
<p>개체의 충돌 연산을 처리하기 위해서는 Collider가 필요하지만 많은 연산이 수행됩니다.</p>

<p>플레이어, 적, 일부 지형과 장애물 등을 제외한 불필요한 오브젝트들은 <strong>충돌처리를 비활성화함으로써 연산량을 크게 낮출 수 있습니다.</strong></p>

<p>에디터에서 수동적으로 콜라이더를 비활성화할 수도 있지만, 재귀함수를 통해 자동으로 처리해 주는 것이 훨씬 간단하고 바람직한 방법입니다.</p>

<p>루트 오브젝트에 해당 스크립트를 수행시키면 자식 오브젝트에 대해 재귀적으로 콜라이더를 비활성화 합니다.</p>

<p>이하는 해당 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void DisableCollider(GameObject obj)
{
    foreach (Transform t in obj.transform)
    {
        if (t.gameObject.HasComponent&lt;MeshCollider&gt;())
            t.gameObject.GetComponent&lt;MeshCollider&gt;().enabled = false;
        DisableCollider(t.gameObject);
    }
}
</code></pre></div></div>
<p>최적화에 해당하진 않으나 플레이어가 바닥에 닿아있는지를 판단하기 위해 바닥 오브젝트에 ‘Terrain’ 태그를 부착하는 것도 재귀적으로 수행했습니다.
<br /></p>
<h2 id="4-finite-state-machine">4. Finite State Machine</h2>
<p>적의 AI를 보다 간편하게 제어하기 위해 상태를 유한 상태 기계로 정의했습니다.</p>

<p>밸런스 패치 등의 이유로 적의 특정 패턴의 빈도를 변경해야 할 경우, 확률값만 바꿔주면 되기 때문에 <strong>직관적인 제어가 가능</strong>합니다.</p>

<p>이하는 해당 구현의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum EnemyState { IDLE, MOVE, ATTACK, SPECIALATTACK }

IEnumerator State()
{
    int rnd = Random.Range(0, 101); // 0~100
    // 15% Taunt 15% Idle(Look) 50% Move 20% SA
    if (!onAttack &amp;&amp; controller.GetComponent&lt;Controller&gt;().cameraState != Controller.State.cutscene)
    {
        if (rnd &lt;= 15 &amp;&amp; state == EnemyState.IDLE)
        {
            Taunt();
        }
        if (rnd &gt; 15 &amp;&amp; rnd &lt;= 30)
        {
            state = EnemyState.IDLE;
        }
        if (rnd &gt; 30 &amp;&amp; rnd &lt;= 80)
        {
            state = EnemyState.MOVE;
        }
        if (rnd &gt; 80)
        {
            state = EnemyState.SPECIALATTACK;
        }
    }
    yield return wait;
    StartCoroutine(State());
}
</code></pre></div></div>
<p>최적화의 일환으로 <code class="language-plaintext highlighter-rouge">WaitForSeconds wait = new WaitForSeconds(3f)</code>를 통해 기다리는 시간을 미리 캐싱해 줍니다.</p>

<p>캐싱해둔 해당 대기시간은 3초이므로 3초마다 정해진 확률에 따라 적의 상태가 변동됩니다.</p>

<p>공격 및 패턴을 수행중이거나 컷씬 상황에서는 상태가 바뀌면 안 되므로 예외처리를 해줍니다.</p>

<p>적이 허공에 공격을 하는 일이 없도록 ‘ATTACK’ 상태는 ‘MOVE’상태 도중에 전이되도록 했습니다.
<br /></p>
<h2 id="5-스킬">5. 스킬</h2>

<p><img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211260&amp;authkey=%21AG1rjc4GEq6TYcg&amp;width=1920&amp;height=1080" alt="SkillSword" />
<img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211256&amp;authkey=%21ABwuoj-KZc2HBSY&amp;width=1920&amp;height=1080" alt="SkillBow" /></p>

<p>보다 많은 컨트롤 요소와 재미를 위해 스킬을 제작했습니다.</p>

<p>검, 활 두 가지의 무기마다 한 가지의 스킬을 사용할 수 있습니다.</p>

<p>검 스킬의 경우 랜덤한 모션을 취하며, 검기의 잔상과 함께 불꽃을 전방으로 방출합니다.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p>

<p>불꽃이 적, 땅, 큰 오브젝트 등에 닿을 경우 이펙트와 함께 폭발하며, 적에게 적중했을 경우 데미지를 줍니다.</p>

<p>활 스킬은 불 붙은 화살을 다수 발사하며, 검 스킬보다 데미지가 높지만 전부 적중시키기 어렵고, 쿨타임이 보다 길며, MP 소모량도 높습니다.</p>

<p>GUI를 통해 스킬의 쿨타임을 실시간으로 확인할 수 있습니다.</p>

<p>상술한 검 스킬 구현의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void OnEnable()
{
    GameObject player = GameObject.Find("Player");
    Vector3 direction = player.transform.forward;
    StartCoroutine(DisableObject());
    StartCoroutine(Move(direction));
    hit = true;
}

IEnumerator Move(Vector3 direction)
{
    transform.Translate(direction * moveSpeed * Time.deltaTime);
    yield return null;
    if(gameObject.activeSelf)
        StartCoroutine(Move(direction));
}
</code></pre></div></div>
<p>스킬을 사용하면 오브젝트 풀링 과정을 통해 스킬 이펙트가 활성화되고, 그 순간의 플레이어의 방향벡터<code class="language-plaintext highlighter-rouge">Vector3 direction</code>를 매개변수로 받아 계속 전진합니다. 따라서 스킬 사용 후 캐릭터가 움직여도 불꽃의 움직임에는 영향이 없습니다.
<br /></p>
<h2 id="6-보스-패턴">6. 보스 패턴</h2>
<p>보스와의 1vs1 전투에서 가장 중요한 요소 중 하나는 특수 패턴입니다.</p>

<p>일반적인 공격 및 도발 패턴 외에, 세 개의 특수 패턴을 구현했습니다.</p>

<h3 id="6-1-어스퀘이크">6-1. 어스퀘이크<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></h3>

<p><img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211257&amp;authkey=%21AGzfKz0yN6XdFUo&amp;width=1920&amp;height=1080" alt="Earthquake" /></p>

<p>적이 제자리에서 공중으로 뛰어오른 후 바닥을 강하게 내려찍습니다. 이 준비동작 동안 데미지를 입을 수 있는 범위에 붉은색으로 경고표시가 짧게 발생됩니다.</p>

<p>이 경고 이펙트의 수단으로 단순한 원형 오브젝트, Pointlight, Spotlight, Projection등을 이용해 다양하게 테스트했고, 가장 시인성이 좋은 Spotlight를 채택했습니다.</p>

<p>땅을 찍는 순간 판정이 발생하며, 이 순간에 범위 밖에 있거나 공중에 있을 시 회피할 수 있습니다.</p>

<p>2페이즈부터는 패턴이 강화되어, 땅을 찍은 후 주위에 랜덤하게 여러 개의 경고 이펙트가 발생하며, 일정 시간 후 해당 위치에 폭발이 추가로 발생합니다.</p>

<p>3번째 특수 패턴인 익스플로전과 결합되면 적절한 타이밍에 회피해야 하는 높은 컨트롤 실력을 요구하게 됩니다.</p>

<p>패턴 구현의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void SpecialHit()
{
    specialHit = true;
    if (specialHit &amp;&amp; GetDistance() &lt;= 15 &amp;&amp; player.GetComponent&lt;Animator&gt;().GetBool("isGround"))
    {
        specialHit = !specialHit;
        player.GetComponent&lt;Animator&gt;().Play("getSpecialHit");
        playerRgd.AddForce(new Vector3(0, 200f, 0));
        if (PlayerAxis.Instance.onAttack)
            PlayerAxis.Instance.onAttack = false;
        if (PlayerAxis.Instance.onCombo)
            PlayerAxis.Instance.onCombo = false;
        if (PlayerAxis.Instance.onSkill)
            PlayerAxis.Instance.onSkill = false;
        if (PlayerAxis.Instance.combo &gt; 0)
            PlayerAxis.Instance.combo = 0;
        if (player.GetComponent&lt;Player&gt;().isRolling)
            player.GetComponent&lt;Player&gt;().isRolling = false;
        HealthCalculation(enemyATK * 5);
    }
    if(phase == 2)
    {
        // 오브젝트 풀링 부분. 생략
    }
}
</code></pre></div></div>
<p>피격 시 크게 쓰러지는 애니메이션이 재생되고 공중으로 튕겨집니다. 수행중이던 모든 행동들이 초기화되고 데미지를 입습니다.
<br /></p>
<h3 id="6-2-러쉬">6-2. 러쉬<sup id="fnref:4:1" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></h3>

<p><img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211255&amp;authkey=%21AJszdAGpGiQxMzg&amp;width=1920&amp;height=1080" alt="Rush" /></p>

<p>2페이즈 부터 사용하는 패턴으로, 적이 몸에 불을 붙이고 빠르게 플레이어에게 돌진합니다.</p>

<p>플레이어에게 붙은 순간 짧게 시간이 느려지며, 시간 안에 패링으로 반격하면 적을 역으로 넘어뜨릴 수 있습니다.</p>

<p>실패할 경우 큰 데미지와 함께 멀리 날아가며, 이 또한 익스플로전과 결합되면 연타를 맞아 위험하기 때문에 막지 못하면 클리어가 매우 어려워지도록 설계했습니다.</p>

<p>패턴 구현의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IEnumerator SpecialAttackRushJudge(float judgeTime)
{
    bool successful = false;
    while (judgeTime &gt; 0)
    {
        yield return null;
        judgeTime -= Time.deltaTime;
        if (player.GetComponent&lt;Player&gt;().playerParry)
        {
            successful = true;
            StartCoroutine(CameraShake.Shake(2f, 3f, 1.5f));
            anim.SetBool("isRushSuccessful", false);
            anim.SetTrigger("rushEnd");
            specialAttackRushEffect.SetActive(false);
            Time.timeScale = 1;
            StartCoroutine(BloomControl.BloomOff(5f));
            yield return new WaitForSeconds(7f);
            onAttack = false;
        }
    }
	// 생략
}
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">judgeTime</code>이내에 패링에 성공했을 경우 느려진 시간이 돌아오며 블룸 효과 및 패턴의 불꽃 이펙트도 사그라듭니다. 적은 넘어지며 7초간 행동불능 상태에 빠집니다.
<br /></p>
<h3 id="6-3-익스플로전">6-3. 익스플로전<sup id="fnref:4:2" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></h3>
<p>최고 난이도 전용 패턴으로, 주기적으로 다음 중 하나를 랜덤하게 수행합니다.</p>
<ul>
  <li>플레이어의 자리에 경고 이펙트가 발생 후 폭발합니다.</li>
  <li>플레이어의 전후좌우 4곳에 경고 이펙트가 발생 후 폭발합니다.<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup></li>
  <li>플레이어 주변에 랜덤하게 여러 개의 경고 이펙트가 발생 후 폭발합니다.</li>
</ul>

<p>패턴 구현의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void SenatorDifficultyGroundExplosion()
{
    // 3개 중 1개의 패턴으로 오브젝트 풀링하여 수행
}

IEnumerator SenatorDifficultyCoroutine()
{
    yield return new WaitForSeconds(Random.Range(7.0f, 10.0f));
    if(controller.GetComponent&lt;Controller&gt;().cameraState != Controller.State.cutscene) // 컷신 중에는 폭발하면 안 되므로
        SenatorDifficultyGroundExplosion();
    if(PlayerAxis.Instance.difficulty == PlayerAxis.Difficulty.senator)
        StartCoroutine(SenatorDifficultyCoroutine());
}
</code></pre></div></div>
<p>7~10초 사이의 랜덤한 간격으로 폭발을 발생시킵니다. 컷씬의 예외처리를 해줍니다.
<br /></p>

<hr data-content="footnotes" />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>High Definition Render Pipeline. 고해상도 렌더 파이프라인으로, 고품질의 3D 렌더링에 적합한 렌더링 방식입니다. 프로젝트 초창기에는 일반 렌더 파이프라인으로 작업했으나, 보다 화려한 이펙트와 그래픽을 위해 변경했습니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Quick Time Event의 약자로 컷씬 도중에 주어지는 지시를 빠르게 수행하는 게임 플레이 방법입니다. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>블리자드의 게임 ‘오버워치’의 영웅 라인하르트의 E스킬 “화염 강타”와 유사한 로직을 갖습니다. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>가칭으로, 코드나 대사 등에는 따로 명칭이 없습니다. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:4:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:4:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>따라서 가만히 그 자리에 있어야 안전합니다. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


        
          <button title="Toggle Theme" class="theme-toggle">
  <svg viewBox="0 0 32 32" width="24" height="24" fill="currentcolor">
    <circle cx="16" cy="16" r="14" fill="none" stroke="currentcolor" stroke-width="4"></circle>
    <path d="
             M 16 0
             A 16 16 0 0 0 16 32
             z">
    </path>
  </svg>
</button>

        
        <div class="credits">&copy;&nbsp;2024&nbsp;이윤찬
          &nbsp;
          •
          &nbsp;Powered by <a href="https://www.soopr.co" target="_blank" rel="noreferrer">Soopr</a>
          &nbsp;
          •
          &nbsp;Theme&nbsp; <a href="https://github.com/abhinavs/moonwalk" target="_blank" rel="noreferrer">Moonwalk</a>
        </div>
      </div>
    </main><script async defer src="https://sdk.soopr.co/soopr.js"></script></body>
</html>
