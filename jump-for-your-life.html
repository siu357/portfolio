<!DOCTYPE html>
<html lang="en" class="html" data-theme="light"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>
    
      Jump For Your Life
    
  </title>

  <!-- Begin Jekyll SEO tag v2.7.3 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Jump For Your Life" />
<meta name="author" content="이윤찬" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="소개" />
<meta property="og:description" content="소개" />
<link rel="canonical" href="http://localhost:4000/jump-for-your-life" />
<meta property="og:url" content="http://localhost:4000/jump-for-your-life" />
<meta property="og:site_name" content="이윤찬의 포트폴리오" />
<meta property="og:image" content="https://soopr.xyz/images/card?url=http://localhost:4000/jump-for-your-life" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-01T00:00:00+09:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="og:image" content="https://soopr.xyz/images/card?url=http://localhost:4000/jump-for-your-life" />
<meta property="twitter:title" content="Jump For Your Life" />
<script type="application/ld+json">
{"url":"http://localhost:4000/jump-for-your-life","headline":"Jump For Your Life","dateModified":"2023-11-01T00:00:00+09:00","datePublished":"2023-11-01T00:00:00+09:00","@type":"BlogPosting","author":{"@type":"Person","name":"이윤찬"},"description":"소개","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jump-for-your-life"},"@context":"https://schema.org"}</script>
<script async defer data-soopr-token="" src="https://sdk.soopr.co/soopr.js"  ></script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="이윤찬의 포트폴리오" />

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/assets/images/favicon/site.webmanifest">
  <link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/assets/images/favicon/favicon.ico">
  <meta name="msapplication-TileColor" content="#00aba9">
  <meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  <!-- Favicon -->

  <link rel="stylesheet" href="/assets/css/main.css" />
  
    <script type="text/javascript">
  window.addEventListener('load', themeChange);
  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme)
    document.documentElement.setAttribute('data-theme', currentTheme);

  function themeChange() {
    let button = document.querySelector('.theme-toggle');

    button.addEventListener('click', function (e) {
      let currentTheme = document.documentElement.getAttribute('data-theme');
      if (currentTheme === 'dark') {
        transition();
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
      } else {
        transition();
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
      }
    });

    let transition = () => {
      document.documentElement.classList.add('transition');
      window.setTimeout(() => {
        document.documentElement.classList.remove('transition');
      }, 1000);
    }
  }
</script>


  
</head>
<body>
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">돌아가기</a>
<h1 class="post-title">Jump For Your Life</h1>
<p class="post-date text-bold">
  
    <span class="text-upcase">이윤찬</span> / 
  
  
    <span class="text-upcase">November 2023</span>
  


  
  
  (2831 Words, 
  16 Minutes)
  

</p>

<div class="soopr-btn"
   data-twitter="SooprCo"
>
</div>


  <div class="">
    
    <span class="tag">Windows API</span>
    
    <span class="tag">C++</span>
    
    <span class="tag">Game Project</span>
    
  </div>


<h1 id="소개">소개</h1>

<p><strong>제작 언어 및 엔진</strong> : C++, Windows API</p>

<p><strong>제작 기간</strong> : 약 2개월</p>

<p>넥슨의 유명 게임 메이플스토리의 장애물 탈출 컨텐츠 ‘인내의 숲’을 모티브로 하여 만든 횡스크롤 게임으로, <strong>메이플스토리 원본 게임의 물리, 카메라워크, 시각효과 등을 유사하게 재현</strong>하는데 초점을 맞췄습니다.</p>

<h1 id="플레이-영상">플레이 영상</h1>

<iframe width="560" height="315" src="https://www.youtube.com/embed/5BVF3L-3T3o?si=-brmBlJSjwc-RAo9" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<ul>
  <li>주요 타임 스탬프
    <ul>
      <li>00:04 : 기본 조작 및 가속/감속 물리</li>
      <li>00:27 : 피격 효과</li>
      <li>00:47 : 게임 플레이</li>
      <li>00:53 : 카메라워크</li>
      <li>01:10 : 스킬 사용</li>
      <li>01:16 : 옵션</li>
      <li>01:22 : UI 투명도</li>
      <li>01:35 : 최대 FPS 설정</li>
      <li>01:46 : 옵션 취소</li>
      <li>01:58 : 스킬 알림이 : Classic</li>
      <li>02:08 : 스킬 알림이 : Alpha Lerp</li>
      <li>02:15 : 다른 환경의 맵</li>
      <li>02:48 : 맵마다 고유한 마찰계수</li>
      <li>03:00 : 시차(Parallax)</li>
    </ul>
  </li>
</ul>

<h1 id="주요-기능">주요 기능</h1>

<ul>
  <li>기본 설계
    <ul>
      <li>클래스의 상속 기능을 적극 활용해 기본 속성을 공유하는 다양한 몬스터를 쉽게 생성할 수 있음</li>
      <li>맵, 타일도 클래스로 설계하여 다양한 형태를 쉽게 생성 가능</li>
      <li>더블 버퍼링</li>
      <li>동기화(컴퓨터의 성능에 물리가 영향받지 않음)</li>
      <li>프레임레이트 조절</li>
    </ul>
  </li>
  <li>물리
    <ul>
      <li>원본 게임과 흡사한 물리</li>
      <li>가속 및 감속 : 등가속/감속 운동</li>
      <li>점프 : 2차함수를 기반으로 설계</li>
      <li>맵마다 고유한 마찰계수</li>
      <li>겉모습으로부터 독립적인 히트박스</li>
    </ul>
  </li>
  <li>연출
    <ul>
      <li>원본 게임과 흡사한 연출</li>
      <li>카메라워크 : 카메라와 플레이어의 거리에 따라 다른 속도로 보간</li>
      <li>시차(Parallax) : Background와 Foreground의 움직임 차이로 입체 효과 부여</li>
      <li>피격 시 폴짝이며 밀려남, 캐릭터가 깜빡거림</li>
      <li>페이드 인/아웃</li>
    </ul>
  </li>
  <li>최적화
    <ul>
      <li>컬링(Culling)으로 불필요한 출력 최소화</li>
      <li>상황에 맞는 출력방식으로 연산 최적화 (BitBlt, TransparentBlt, StretchBlt, AlphaBlend…)</li>
      <li>캐싱(게임 중간에 로딩으로 인한 성능 저하 없음)</li>
    </ul>
  </li>
  <li>플레이어 및 몬스터
    <ul>
      <li>원본 게임과 흡사한 움직임</li>
      <li>몬스터 AI</li>
      <li>FPS에 영향 받지 않는 애니메이션</li>
    </ul>
  </li>
  <li>컨트롤
    <ul>
      <li>이동, 점프, 엎드리기 : 히트박스의 변화</li>
      <li>스킬 : 일정시간 적의 공격을 회피<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, 지속시간 내 재사용 시 취소</li>
    </ul>
  </li>
  <li>옵션
    <ul>
      <li>마우스로 선택하거나 Esc키로 옵션창 선택</li>
      <li>FPS 제한 수치 선택(60/144)</li>
      <li>UI 투명도 조절</li>
      <li>스킬 쿨타임 알림이 스타일 변경(Classic, Alpha Lerp)</li>
      <li>적용, 취소 버튼</li>
    </ul>
  </li>
  <li>GUI 및 애니메이션 효과
    <ul>
      <li>체력바 : 수치의 변동량이 클 수록 빠르게 변화</li>
      <li>체력이 다 하면 페이드 아웃과 함께 게임오버 문구 표시</li>
      <li>재도전, 종료 선택</li>
    </ul>
  </li>
</ul>

<h1 id="주요-기술-및-코드">주요 기술 및 코드</h1>

<h2 id="1-상속을-통한-계층적-설계">1. 상속을 통한 계층적 설계</h2>
<p>클래스의 주요 속성중 하나로 상속성이 있습니다.</p>

<p>게임의 다양성을 위해서는 다양한 종류의 몬스터, 맵, 타일 등이 필요할 것입니다. <strong>뼈대가 되는 클래스를 만든 후 하위 클래스들을 설계하면 불필요한 반복 코드를 최소화할 수 있고 코드의 가독성도 훨씬 좋아집니다.</strong></p>

<p>본 프로젝트에서는 크게 플레이어, 맵 두 개의 뼈대 클래스가 존재합니다.</p>
<ul>
  <li>플레이어 클래스는 캐릭터의 행동에 따른 애니메이션 출력, 이동, 물리 등이 들어있습니다. 하위 클래스인 몬스터 클래스에서는 추가적으로 필요한 AI를 정의했습니다.</li>
  <li>맵 클래스는 맵의 크기, 배경, vector 템플릿에 담긴 타일<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, 충돌정보, 마찰계수 등이 들어있습니다.</li>
</ul>

<p>이하는 클래스 설계의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CMap
{
public:
	CMap();
	CMap(HWND hWnd, HINSTANCE g_hInst, int width, int height, int theme, double frictionCoefficient, int stage);
	~CMap();

	int GetMapWidth() { return nWidth; }
	int GetMapHeight() { return nHeight; }
	void SetMapResolution(int width, int height);

	void CreateCollision();
	void InitializeCollision();
	int** GetMapCollision() { return nCollision; }
	void SetMapCollision(int** collision);

	double GetFrictionCoefficient() { return dFrictionCoefficient; }
	HBITMAP GetBackgroundBitmap() { return MyStretchedBitmap; }
	BITMAP GetBackgroundInfo() { return BackBit; }
	HDC GetBackgroundDC() { return imgStretchedDC; }

	HBITMAP GetMapBitmap() { return MyMemBitmap; }
	HDC GetMapDC() { return memDC; }

	void DisplayBackground(RECT clientRT);

	void CreateTiles(HWND hWnd, HINSTANCE g_hInst, int stage);
	vector&lt;CTile&gt; GetTileVector() { return vTile; }
	void PrintTiles(RECT clientRT);
	void MakeMapCollision();

private:
	int nBackWidth, nBackHeight;
	int** nCollision;
	double dFrictionCoefficient;
	// 일부 변수 생략
};
</code></pre></div></div>
<p>코드 전체에서 공통적으로 함수 및 클래스 등은 파스칼 표기법, 매개변수를 제외한 다른 변수는 헝가리안 표기법으로 표기했습니다.
<br /></p>
<h2 id="2-동기화-및-프레임레이트">2. 동기화 및 프레임레이트</h2>
<p>유저들의 컴퓨터 사양은 모두 제각각입니다. <strong>정상적인 연산을 위한 최소사양만 만족한다면 사양의 차이로 인해 게임 플레이에 변화가 생기지 않도록 해야 제대로 설계했다</strong>고 할 수 있습니다.</p>

<p>예를 들어 10년 된 저가 컴퓨터와 최신, 최고사양의 컴퓨터가 있다고 했을 때 최신 컴퓨터의 CPU 클럭이 더 높아서 초당 더 많은 연산을 해 더 빠르게 움직이면 안 될 것입니다. 따라서 정해진 주기마다 물리 및 출력 연산을 시행하도록 동기화 과정이 필수적입니다.</p>

<p>프레임레이트의 고정은 정의한 주기에 맞추어 출력을 수행하면 됩니다. 본 작품은 설정에서 60/144Hz를 선택할 수 있도록 했으나, 헤더에서 정의한 값을 수정하면 다른 수치도 가능합니다.</p>

<p>이하는 동기화 작업 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fCurrentTimeUpdate = (float)timeGetTime();
fCurrentTimeAI = (float)timeGetTime();
fCurrentTimeRender = (float)timeGetTime();
fCurrentTimeCamera = (float)timeGetTime();

fDeltaTimeUpdate = (fCurrentTimeUpdate - fStartTimeUpdate) * 0.001f; // ms단위 값
fDeltaTimeAI = (fCurrentTimeAI - fStartTimeAI) * 0.001f; // ms단위 값
fDeltaTimeRender = (fCurrentTimeRender - fStartTimeRender) * 0.001f; // ms단위 값
fDeltaTimeCamera = (fCurrentTimeCamera - fStartTimeCamera) * 0.001f; // ms단위 값

// Update
if (fDeltaTimeUpdate &gt;= __UPDATE_PERIOD__)
{
	Update(hWnd);
	fStartTimeUpdate = fCurrentTimeUpdate;
}

// AI
if (fDeltaTimeAI &gt;= __AISTATE_CHANGE_INTERVAL__)
{
	for (int i = 0; i &lt; vMonsters.size(); i++)
		vMonsters[i].ChangeAIState();
	fStartTimeAI = fCurrentTimeAI;
}

// Render
if (fDeltaTimeRender &gt;= __FPS__(player-&gt;GetDesiredFPS()))
{
	Render(hWnd);
	nFrameCount++;

	fTimeElapsed += fDeltaTimeRender;
	fStartTimeRender = fCurrentTimeRender;

	if (fTimeElapsed &gt;= 1.0f) // FPS Update
	{
		nFrameLatest = nFrameCount;
		nFrameCount = 0;
		fTimeElapsed = 0;
	}
}

// Camera
if (fDeltaTimeCamera &gt;= __CAM_PERIOD__)
{
	player-&gt;UpdateCameraOffset(currentMap);
	fStartTimeCamera = fCurrentTimeCamera;
}
</code></pre></div></div>
<p>본 작품에서는 2ms마다 물리연산을 수행하도록 설계<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>했기 때문에 최소사양 기준은 이 물리연산이 딜레이 없이 수행되는 것입니다.</p>

<p>물리연산에 해당하는 <code class="language-plaintext highlighter-rouge">Update()</code>는 다행히 오버헤드가 크지 않기 때문에 최소사양은 높지 않습니다. 정의한 프레임레이트에 따라 화면을 더블버퍼링으로 출력하는 <code class="language-plaintext highlighter-rouge">Render()</code>는 오버헤드가 크기 때문에 프레임제한을 해제하면 CPU의 성능을 최대치로 활용하게 됩니다.</p>

<p>많은 테스트와 최적화를 거듭해 프레임 제한 해제 시 약 800FPS까지 동작합니다.
<br /></p>
<h2 id="3-물리">3. 물리</h2>
<p>프로젝트의 디테일을 높이기 위해 많은 고민을 했고, 단순히 원본 게임의 모작을 만드는 것을 넘어 시뮬레이터에 가깝도록 원본과 유사하게 만드는 것을 목표로 작업했습니다. 물리는 그 작업의 일환으로, <strong>원본 게임인 메이플스토리의 물리를 최대한 모사</strong>했습니다.</p>

<p>메이플스토리를 플레이 해보신 분들은 알겠지만, 플레이어와 몬스터 등의 개체는 등속운동을 하지 않습니다. 정지상태에서 최대속도에 도달할 때까지 가속합니다. 멈출 때도 갑자기 제자리에 우뚝 서면 어색하므로 서서히 감속합니다.</p>

<p>점프도 마찬가지로 가속 및 감속하며, 본 프로젝트에서는 2차함수로 설계했습니다.</p>

<p>또한 맵의 테마에 따라 얼음장판과 같은 바닥이 미끄러운 환경도 존재합니다. 맵을 생성할 때 마찰계수를 선언할 수 있으며, 계수가 낮으면 천천히 감속하게 됩니다.</p>

<p>이하는 키를 누르지 않았을 때 천천히 감속하는 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!GetAsyncKeyState(VK_LEFT) &amp;&amp; !GetAsyncKeyState(VK_RIGHT))
{
	if (dCharacterCurrentSpeed &gt; 0)
	{
		if (nCharacterState == __JUMP__)
			dCharacterCurrentSpeed -= dCharacterAcceleration * __JUMP_SLOW_FACTOR__;
		else
			dCharacterCurrentSpeed -= dCharacterAcceleration * map-&gt;GetFrictionCoefficient();

		dMoveCount += dCharacterCurrentSpeed;

		if (nCharacterDirection == __LEFT__)
		{
			while (dMoveCount &gt;= __MOVECOUNT_THRESHOLD__)
			{
				dMoveCount -= __MOVECOUNT_THRESHOLD__;
				if (rRigidBody.left &gt; 0)
				{
					rRigidBody.left--;
					rRigidBody.right--;
					UpdateCoordinate();
				}
			}
		}
		else if (nCharacterDirection == __RIGHT__)
		{
			while (dMoveCount &gt;= __MOVECOUNT_THRESHOLD__)
			{
				dMoveCount -= __MOVECOUNT_THRESHOLD__;
				if (rRigidBody.right &lt; map-&gt;GetMapWidth())
				{
					rRigidBody.left++;
					rRigidBody.right++;
					UpdateCoordinate();
				}
			}
		}
	}
	else
	{
		dCharacterCurrentSpeed = 0;
	}
}
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">map-&gt;GetFrictionCoefficient()</code>로 현재 맵의 마찰 계수를 반환받아 사용합니다. 공중에선 공기저항만 존재하고 바닥의 마찰은 영향받지 않으므로 마찰계수를 적용하지 않습니다.
<br /></p>
<h2 id="4-연출">4. 연출</h2>
<p>물리와 마찬가지로 프로젝트의 완성도를 위해 <strong>메이플스토리의 연출을 모사</strong>했습니다.</p>

<p>연출은 크게 카메라워크, 시차, 피격 연출로 나뉩니다.</p>

<h3 id="4-1-카메라워크-보간법">4-1. 카메라워크 보간법</h3>

<p><img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211263&amp;authkey=%21AAJKQjjHVyzmFOI&amp;width=1920&amp;height=1080" alt="Camwork" />
(gif 로딩에 문제가 있어 정적인 이미지로 대체합니다. 영상을 참조해 주세요.)</p>

<p>게임을 영화에 비유해보겠습니다. 카메라는 주인공인 플레이어에 포커스를 맞춰 촬영하고, 이 촬영의 결과가 유저가 보는 화면입니다. 피사체가 움직이면 카메라도 그에 맞춰 움직이지만, 기계처럼 완벽하게 따라갈 수는 없으며 필연적인 딜레이가 생기게 됩니다.</p>

<p>물론 게임은 수GHz의 성능을 가진 카메라, 즉 CPU가 있기 때문에 플레이어가 아무리 빠르게 움직여도 중심에서 벗어나는 일은 없습니다. 하지만 메이플스토리는 자연스러운 연출을 위해 의도적으로 딜레이를 만들었으며, 딜레이도 동일하지 않고, 플레이어와 카메라의 거리가 멀 수록 더 빠르게 따라갑니다.
 예를 들어 플레이어가 순간이동하여 좌표가 순식간에 변경되면, 카메라는 매우 빠른 속도로 플레이어를 쫓아가지만, 가까이 도달하면 점점 그 속도가 느려집니다. 저는 이를 카메라 보간이라고 부르며, 본 작품에도 동일하게 연출하는데 성공했습니다.</p>

<p>카메라 보간법 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void CUnit::UpdateCameraOffset(CMap* map)
{
	// 항상 거리차의 1/n만큼 보간, n은 define에서 정의
	/*
	bufferRT.left, bufferRT.top : 함수가 호출되는 시점에서 카메라 좌표가 도달해야 하는 최종 지점 (__CAMSPEED__가 1이면 1번에 도달할 것)
	nCameraX, nCameraY : 현재 카메라 좌표.
	*/

	double dx = pow(abs(nCoorX - nCameraX), 2);
	double dy = pow(abs(nCoorY - nCameraY), 2);
	double dStep = sqrt(dx + dy) / __CAM_SPEED__;
	if (dStep &lt; __CAMCOUNT_LOWERLIMIT__)
		dCamCount += __CAMCOUNT_LOWERLIMIT__;
	else
		dCamCount += dStep; // 거리차가 멀 수록 Count값이 더 빠르게 올라감 (더 많이, 자주 카메라 워크 실시)

	while (dCamCount &gt;= __CAMCOUNT_THRESHOLD__)
	{
		dCamCount -= __CAMCOUNT_THRESHOLD__;
		if (nCoorX &gt; nCameraX) // 목표 지점이 더 오른쪽
		{
			if ((nCoorX - nCameraX) / __CAM_SPEED__ &lt; 1.0)
				nCameraX++;
			else
				nCameraX += (nCoorX - nCameraX) / __CAM_SPEED__;
		}
		else if (nCoorX &lt; nCameraX)
		{
			if ((nCameraX - nCoorX) / __CAM_SPEED__ &lt; 1.0)
				nCameraX--;
			else
				nCameraX -= (nCameraX - nCoorX) / __CAM_SPEED__;
		}

		if (nCoorY &gt; nCameraY)
		{
			if ((nCoorY - nCameraY) / __CAM_SPEED__ &lt; 1.0)
				nCameraY++;
			else
				nCameraY += (nCoorY - nCameraY) / __CAM_SPEED__;
		}
		else if (nCoorY &lt; nCameraY)
		{
			if ((nCameraY - nCoorY) / __CAM_SPEED__ &lt; 1.0)
				nCameraY--;
			else
				nCameraY -= (nCameraY - nCoorY) / __CAM_SPEED__;
		}
	}
}
</code></pre></div></div>
<p><br /></p>
<h3 id="4-2-시차parallax">4-2. 시차(Parallax)</h3>
<p>쉽게 놓칠 수 있는 부분이지만, 메이플스토리를 플레이하면 뒷배경에서 원근감을 느낄 수 있습니다.</p>

<p>약간 멀리 있는듯한 느낌을 주기 위해 피사계 심도(Depth of Field)가 적용되어 뿌연 느낌이 들고, 사막에서 플레이어가 맵의 처음부터 끝까지 이동해도 배경의 피라미드는 거의 움직이지 않은 것처럼 보입니다.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup></p>

<p>시차의 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void CMap::DisplayBackground(RECT clientRT)
{
	// 적당한 크기만큼 늘려진 배경 (nBackWidth, nBackHeight)의 '시작 좌표'를 비율에 맞추어 정하고, 클라이언트 영역만큼을 출력
	int nGapWidth = abs(nWidth - nBackWidth);
	int nGapHeight = abs(nHeight - nBackHeight);
	BitBlt(memDC, clientRT.left, clientRT.top, __PROGRAM_WIDTH__, __PROGRAM_HEIGHT__, imgStretchedDC, clientRT.left*nGapWidth/nWidth, clientRT.top*nGapHeight/nHeight, SRCCOPY);
}
</code></pre></div></div>
<p>기술적인 부분으로, 시차를 구현하기 위해서는 먼저 게임 스크린의 해상도와 현재 맵의 크기, 배경화면의 크기를 알아야 합니다.</p>

<p>만약 해상도가 맵의 크기보다 크다면 맵의 전체를 출력하고도 공간이 남기 때문에 가장자리가 잘리고, 반대로 맵이 더 크다면 스크린은 맵의 일부만을 출력하게 됩니다.</p>

<p>배경의 크기가 맵과 동일하면 전혀 입체감을 느낄 수 없습니다. 따라서 시차를 구현하기 위한 배경 크기의 필요조건은 <code class="language-plaintext highlighter-rouge">해상도 &lt; 배경의 크기 &lt; 맵의 크기</code>이며, 가장 이상적인 수치는 <code class="language-plaintext highlighter-rouge">( 해상도 + 맵의 크기 ) / 2</code>입니다. 본 작품에서는 사전작업으로 배경을 이 수치로 맞춥니다.
<br /></p>
<h3 id="4-3-피격-효과">4-3. 피격 효과</h3>

<p><img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211261&amp;authkey=%21AJ39kUEw6Qh5nGo&amp;width=1920&amp;height=1080" alt="Hit" /></p>

<p>원본 게임에서 플레이어가 몬스터의 ‘몸통 박치기’를 맞게 되면 아파하는 표정과 함께 반대방향으로 튕겨나가며, 깜박이는 묘사와 함께 일정시간동안 무적이 됩니다.</p>

<p>이를 모사한 구현 과정입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL CUnit::Collide(CUnit target)
{
	if (bInvincible || bSkillDarkSight) // 무적 상태, 다크사이트 상태에서는 충돌처리 X
		return FALSE;
	if ((rRigidBody.top &lt;= target.rRigidBody.bottom &amp;&amp; rRigidBody.bottom &gt;= target.rRigidBody.bottom) || (rRigidBody.top &lt;= target.rRigidBody.top &amp;&amp; rRigidBody.bottom &gt;= target.rRigidBody.top))
	{
		// Player collides with the target from the leftside
		if (rRigidBody.right &gt; target.rRigidBody.left &amp;&amp; rRigidBody.right &lt; target.rRigidBody.right)
		{
			dCharacterCurrentSpeed = dCharacterSpeed;
			dCurrentForce -= __COLLISION_FORCE__;
			bInvincible = true;
			bOuch = true;
			bHitGround = false;
			nCurrentHp -= target.nATK;
			return TRUE;
		}
		// Vice Versa
		else if (rRigidBody.left &lt; target.rRigidBody.right &amp;&amp; rRigidBody.left &gt; target.rRigidBody.left)
		{
			dCharacterCurrentSpeed = dCharacterSpeed;
			dCurrentForce += __COLLISION_FORCE__;
			bInvincible = true;
			bOuch = true;
			bHitGround = false;
			nCurrentHp -= target.nATK;
			return TRUE;
		}
	}
}

void CUnit::Force(CMap* map)
{
	if (dCurrentForce != 0)
	{
		if (dCurrentForce &lt; 0) // 음수.  dCurrentForce가 0으로 수렴할 때까지 왼쪽으로 밀려남
		{
			if (dCurrentForce + dCharacterAcceleration * map-&gt;GetFrictionCoefficient() &gt; 0)
				dCurrentForce = 0;
			else
				dCurrentForce += dCharacterAcceleration * map-&gt;GetFrictionCoefficient();
			dForceCount += abs(dCurrentForce);

			if (dForceCount &gt;= __MOVECOUNT_THRESHOLD__)
			{
				dForceCount -= __MOVECOUNT_THRESHOLD__;
				if (rRigidBody.left &gt; 0)
				{
					rRigidBody.left--;
					rRigidBody.right--;
				}
				if (!bHitGround)
				{
					rRigidBody.top -= __JUMP_COLLISION_CHECK_ACCURACY__;
					rRigidBody.bottom -= __JUMP_COLLISION_CHECK_ACCURACY__;
				}
				UpdateCoordinate();
			}
		}
		else if (dCurrentForce &gt; 0) // 양수.  dCurrentForce가 0으로 수렴할 때까지 오른쪽으로 밀려남
		{
			if (dCurrentForce - dCharacterAcceleration * map-&gt;GetFrictionCoefficient() &lt; 0)
				dCurrentForce = 0;
			else
				dCurrentForce -= dCharacterAcceleration * map-&gt;GetFrictionCoefficient();
			dForceCount += dCurrentForce;

			if (dForceCount &gt;= __MOVECOUNT_THRESHOLD__)
			{
				dForceCount -= __MOVECOUNT_THRESHOLD__;
				if (rRigidBody.right &lt; map-&gt;GetMapWidth())
				{
					rRigidBody.left++;
					rRigidBody.right++;
				}
				if (!bHitGround)
				{
					rRigidBody.top -= __JUMP_COLLISION_CHECK_ACCURACY__;
					rRigidBody.bottom -= __JUMP_COLLISION_CHECK_ACCURACY__;
				}
				UpdateCoordinate();
			}
		}
	}
}
</code></pre></div></div>
<p>플레이어가 충돌 범위 안에 들어왔을 때 <code class="language-plaintext highlighter-rouge">__COLLISION_FORCE__</code>만큼의 충격량을 받습니다. 부호에 따라 방향에 차이가 생깁니다.
<br /></p>
<h2 id="5-최적화">5. 최적화</h2>
<p>게임 리뷰들을 보면 훌륭한 게임성과 작품성으로 칭찬받지만, 고사양 PC로도 원활한 플레이를 할 수 없어 평가점수가 깎이는 경우를 종종 볼 수 있습니다.</p>

<p>이처럼 <strong>좋은 게임의 이면에는 반드시 어느정도의 최적화가 필요합니다.</strong> 본 프로젝트는 고성능의 PC를 요구하는 작업을 하진 않지만, 그렇다고 최적화를 소홀히 할 순 없습니다. 기능이 추가되어 고사양이 될 수도 있고, 다른 게임을 만들 때 고사양을 요하는 작업이 포함될 수도 있으니까요.</p>

<h3 id="5-1-컬링culling">5-1. 컬링(Culling)</h3>
<p>자주 쓰이는 최적화 방법 중 하나입니다. 카메라의 범위를 벗어나거나 다른 오브젝트에 가려져서 보이지 않는 부분은 출력할 필요가 없기 때문에 출력할 필요가 없습니다.
 다만 보이지 않는 상태에서도 움직이는 등의 활동은 계속해야 하므로 물리연산은 계속 실시합니다.</p>

<p>컬링 코드입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void Render(HWND hWnd)
{
	hdc = GetDC(hWnd);
	clientRT = player-&gt;GetClientRegion(currentMap);

	/* Background */
	currentMap-&gt;DisplayBackground(clientRT);

	/* Tiles */
	currentMap-&gt;PrintTiles(clientRT);

	/* Monsters */
	for (int i = 0; i &lt; vMonsters.size(); i++)
		vMonsters[i].DisplayCharacter(memDC, clientRT);

	/* Characters&amp; tiles */ 
	player-&gt;DisplayCharacter(memDC, clientRT);

	/* Foreground */
	// 생략

	/* UI */
	// 생략
	
	DoubleBuffer(hWnd, memDC);

	ReleaseDC(hWnd, hdc);
}

void CUnit::DisplayCharacter(HDC memDC, RECT clientRT)
{
	if (rRigidBody.left &gt; clientRT.right ||
		rRigidBody.right &lt; clientRT.left ||
		rRigidBody.top &gt; clientRT.bottom ||
		rRigidBody.bottom &lt; clientRT.top)return;
	
	// 개체 출력 과정 생략
}
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">GetClientRegion(currentMap)</code>으로 현재 맵에서 카메라가 촬영하고 있는 해상도만큼의 범위를 반환받고, 오브젝트가 이 범위 밖에 있다면 출력 과정을 생략합니다.
<br /></p>
<h3 id="5-2-blt-선택">5-2. Blt 선택</h3>
<p>먼저 Windows API에서 이미지를 출력하는 방법 몇 가지를 간략하게 설명하겠습니다.</p>
<ul>
  <li>BitBlt : 가장 기본적인 방법으로, DC<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>에 담긴 정보를 원하는 좌표에 그대로 출력합니다.</li>
  <li>TransparentBlt : 매개변수로 입력한 ‘마스크’에 해당하는 색은 출력하지 않고 나머지만 출력합니다.<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></li>
  <li>StretchBlt : 원본 DC를 매개변수로 입력한 크기에 맞게 축소하거나 늘려서 출력합니다. 뒤집어서 출력하는 것도 가능합니다.</li>
  <li>AlphaBlend : DC에는 기본적으로 bmp포맷이 들어가기 때문에 png에 있는 투명도(A)가 없습니다. 해당 기능을 사용하면 bmp에 투명도를 적용할 수 있습니다.
각 방법들은 조합하여 사용할 수 있습니다. 예를 들어 반투명한 늘려진 이미지를 만드는 것도 가능합니다. (단, 정해진 순서로 연산해야 어색하지 않습니다.)</li>
</ul>

<p>당연히 BitBlt의 오버헤드가 가장 적으며, 이외의 방식은 연산량이 많습니다.
 맵에서 플레이어가 딛는 바닥의 밑에 해당하는 타일들은 이미지의 모든 부분을 사용하기 때문에 TransparentBlt를 사용할 필요가 없습니다.
 최적화를 위해서는 가급적 BitBlt를 사용하는 것이 바람직하며, 이렇게 최적화 완료 후 최적화 전 대비 약 30%(600대 -&gt; 800대)<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>의 프레임 향상을 확인했습니다.</p>

<p>이하는 경우에 따라 Blt를 선택한 코드의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void CMap::PrintTiles(RECT clientRT)
{
	for (int i = 0; i &lt; vTile.size(); i++)
	{
		if (vTile[i].GetCoordinateX() &gt; clientRT.right || vTile[i].GetCoordinateX() + vTile[i].GetWidth() &lt; clientRT.left || vTile[i].GetCoordinateY() &gt; clientRT.bottom || vTile[i].GetCoordinateY() + vTile[i].GetHeight() &lt; clientRT.top)continue;
		TransparentBlt(memDC, vTile[i].GetCoordinateX(), vTile[i].GetCoordinateY(), vTile[i].GetWidth(), vTile[i].GetHeight(), vTile[i].GetTileDC(), 0, 0, vTile[i].GetWidth(), vTile[i].GetHeight(), vTile[i].GetColorKey());
	}
	for (int i = 0; i &lt; vTileBed.size(); i++)
	{
		if (vTileBed[i].GetCoordinateX() &gt; clientRT.right || vTileBed[i].GetCoordinateX() + vTileBed[i].GetWidth() &lt; clientRT.left || vTileBed[i].GetCoordinateY() &gt; clientRT.bottom || vTileBed[i].GetCoordinateY() + vTileBed[i].GetHeight() &lt; clientRT.top)continue;
		BitBlt(memDC, vTileBed[i].GetCoordinateX(), vTileBed[i].GetCoordinateY(), vTileBed[i].GetWidth(), vTileBed[i].GetHeight(), vTileBed[i].GetTileDC(), 0, 0, SRCCOPY);
	}
}
</code></pre></div></div>
<p>모든 소스는 직사각형 비트맵 이미지이기 때문에 플레이어등의 개체가 발을 딛는 표면은 투명처리가 불가피합니다. 반대로 그 밑에 해당하는 부분은 따로 vTileBed에 저장되어 있으며 BitBlt로 출력해 오버헤드를 최소화합니다.
<br /></p>
<h3 id="5-3-캐싱caching">5-3. 캐싱(Caching)</h3>
<p>게임 시작 시 맵에서 사용될 모든 개체들을 미리 메모리에 동적할당합니다. 해당 맵을 벗어나면 더이상 필요하지 않기 때문에 해제합니다. 똑같은 몬스터 개체가 다음 맵에도 등장하면 다시 생성하지 않고 재활용합니다.
<br /></p>
<h2 id="6-옵션-및-스킬-알림이">6. 옵션 및 스킬 알림이</h2>

<p><img src="https://onedrive.live.com/embed?resid=E08FD3FFC3FC8447%211262&amp;authkey=%21ALkxG2nIar1On1E&amp;width=1920&amp;height=1080" alt="Option" /></p>

<ul>
  <li>옵션</li>
</ul>

<p>심플한 옵션창을 설계했습니다. 설정 버튼을 클릭하거나 Esc키를 누르면 옵션창이 열리며, OK를 눌러 적용, Cancel이나 Esc키로 취소합니다.
 옵션창을 여는 순간의 기존 설정을 임시로 저장해서 유저가 값을 변경해도 취소를 누르면 저장된 값으로 롤백됩니다.</p>

<ul>
  <li>스킬 알림이</li>
</ul>

<p>스킬 사용 후 지속시간 안에 다시 스킬을 사용하거나 지속시간이 종료되면 쿨타임이 흐르기 시작합니다. 두 개의 쿨타임 표시 스타일을 제작해 보았습니다.</p>
<ul>
  <li>Classic : 원본 게임의 스타일과 같습니다. 쿨타임이 적용되면 아이콘이 어두워지며 어두운 부분이 점점 사라집니다.</li>
  <li>Alpha Lerp : 쿨타임이 적용되면 아이콘이 어두워지며 점점 밝아집니다.</li>
</ul>

<p>구현 코드의 일부입니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void CUnit::UIOptionDisplay(HDC memDC, RECT clientRT)
{
	if (!bUIOption)
		return;
	int nScreenLeft = clientRT.left + __PROGRAM_WIDTH__ / 2 - UIOptionBitmap.bmWidth / 2;
	int nScreenTop = clientRT.top + __PROGRAM_HEIGHT__ / 2 - UIOptionBitmap.bmHeight / 2;

	// Option Screen
	BitBlt(memDC,
		nScreenLeft,
		nScreenTop,
		UIOptionBitmap.bmWidth,
		UIOptionBitmap.bmHeight,
		UIOptionDC,
		0, 0, SRCCOPY);

	// Boxes
	/*
	Classic : 86, 76
	Alpha Lerp : 176, 76

	60 : 86, 126
	144 : 176, 126
	*/
	if (nSkillCooldownPrintStyle == __CLASSIC__)
	{
		BitBlt(memDC, nScreenLeft + 86, nScreenTop + 76, UIOptionBoxOnBitmap.bmWidth, UIOptionBoxOnBitmap.bmHeight, UIOptionBoxOnDC, 0, 0, SRCCOPY);
		BitBlt(memDC, nScreenLeft + 176, nScreenTop + 76, UIOptionBoxOffBitmap.bmWidth, UIOptionBoxOffBitmap.bmHeight, UIOptionBoxOffDC, 0, 0, SRCCOPY);
	}
	else if (nSkillCooldownPrintStyle == __ALPHA_LERP__)
	{
		BitBlt(memDC, nScreenLeft + 176, nScreenTop + 76, UIOptionBoxOnBitmap.bmWidth, UIOptionBoxOnBitmap.bmHeight, UIOptionBoxOnDC, 0, 0, SRCCOPY);
		BitBlt(memDC, nScreenLeft + 86, nScreenTop + 76, UIOptionBoxOffBitmap.bmWidth, UIOptionBoxOffBitmap.bmHeight, UIOptionBoxOffDC, 0, 0, SRCCOPY);
	}

	if (nDesiredFPS == 60)
	{
		BitBlt(memDC, nScreenLeft + 86, nScreenTop + 126, UIOptionBoxOnBitmap.bmWidth, UIOptionBoxOnBitmap.bmHeight, UIOptionBoxOnDC, 0, 0, SRCCOPY);
		BitBlt(memDC, nScreenLeft + 176, nScreenTop + 126, UIOptionBoxOffBitmap.bmWidth, UIOptionBoxOffBitmap.bmHeight, UIOptionBoxOffDC, 0, 0, SRCCOPY);
	}
	else if (nDesiredFPS == 144)
	{
		BitBlt(memDC, nScreenLeft + 176, nScreenTop + 126, UIOptionBoxOnBitmap.bmWidth, UIOptionBoxOnBitmap.bmHeight, UIOptionBoxOnDC, 0, 0, SRCCOPY);
		BitBlt(memDC, nScreenLeft + 86, nScreenTop + 126, UIOptionBoxOffBitmap.bmWidth, UIOptionBoxOffBitmap.bmHeight, UIOptionBoxOffDC, 0, 0, SRCCOPY);
	}
	else // define.h에서 값을 60, 144 외 임의의 값으로 정해놨을 경우
	{
		BitBlt(memDC, nScreenLeft + 86, nScreenTop + 126, UIOptionBoxOffBitmap.bmWidth, UIOptionBoxOffBitmap.bmHeight, UIOptionBoxOffDC, 0, 0, SRCCOPY);
		BitBlt(memDC, nScreenLeft + 176, nScreenTop + 126, UIOptionBoxOffBitmap.bmWidth, UIOptionBoxOffBitmap.bmHeight, UIOptionBoxOffDC, 0, 0, SRCCOPY);
	}

	// Scroll
	/*
	Min : 88, 35
	Max : 262, 35
	Gap : 174
	Transparency : 255 -&gt; 262
	Transparency : 0 -&gt; 88
	*/

	TransparentBlt(memDC, nScreenLeft + 88 + (double)nUITransparency/255*174, nScreenTop + 35, UIOptionScrollBitmap.bmWidth, UIOptionScrollBitmap.bmHeight, UIOptionScrollDC, 0, 0, UIOptionScrollBitmap.bmWidth, UIOptionScrollBitmap.bmHeight, colorKey);
}
</code></pre></div></div>
<p>옵션에서 해당하는 부분이 활성화된 경우 아이콘을 체크 표시로 바꿔주고, 스크롤의 커서도 현재 설정된 값에 맞게 보정합니다.
<br /></p>

<hr data-content="footnotes" />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>메이플스토리 도적 직업군의 스킬 ‘다크 사이트’와 동일합니다. 연출도 똑같이 반투명해집니다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>타일은 발판 생성의 편리함을 위해 별도로 타일 클래스를 설계했습니다. 각각의 맵은 vector<vTile>로 구성된 타일 집합을 가집니다.</vTile> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>가속, 감속 등을 부드럽게 연출하기 위해서는 높은 클럭이 필수적입니다. 즉 사양의 제한만 없다면 최소 단위가 작을 수록 좋습니다. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>실생활을 예로 들면 잠실의 롯데타워는 서울이 아닌 경기권에서도 보이는데, 서울 방향으로 10분 정도 운전해도 비슷한 위치에 비슷한 크기로 있는 것을 알 수 있습니다. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>Device Context. Windows API에서 이미지를 입력받아 이를 저장해 두는 영역입니다. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>CG를 사용하는 영화의 촬영장면을 보면 뒷배경으로 녹색 천을 사용하는 것을 보신 적이 있을 겁니다. 후처리 작업 때 이 배경을 제거하고 컴퓨터그래픽을 입히는데, 주로 자연에 흔하게 존재하지 않는 색을 이 배경색으로 채택합니다. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>프레임제한을 해제해 최대한 많은 <code class="language-plaintext highlighter-rouge">Render()</code>를 수행했을 경우입니다. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


        
          <button title="Toggle Theme" class="theme-toggle">
  <svg viewBox="0 0 32 32" width="24" height="24" fill="currentcolor">
    <circle cx="16" cy="16" r="14" fill="none" stroke="currentcolor" stroke-width="4"></circle>
    <path d="
             M 16 0
             A 16 16 0 0 0 16 32
             z">
    </path>
  </svg>
</button>

        
        <div class="credits">&copy;&nbsp;2024&nbsp;이윤찬
          &nbsp;
          •
          &nbsp;Powered by <a href="https://www.soopr.co" target="_blank" rel="noreferrer">Soopr</a>
          &nbsp;
          •
          &nbsp;Theme&nbsp; <a href="https://github.com/abhinavs/moonwalk" target="_blank" rel="noreferrer">Moonwalk</a>
        </div>
      </div>
    </main><script async defer src="https://sdk.soopr.co/soopr.js"></script></body>
</html>
